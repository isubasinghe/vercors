/* TODO: Requires to pass: --assumeInjectivityOnInhale, fix s.t. inlining leaves obvious triggers alone
         And even then, still takes long: 4m20s when running viper manually. */

class Move {
  int x;
  int y;
  int t;

  ensures this.x == x;
  ensures this.y == y;
  ensures this.t == t;
  constructor(int x, int y, int t);

  ensures \old(x) == x && x == \result.x;
  ensures \old(y) == y && y == \result.y;
  ensures \old(t) == t && t == \result.t;
  Move clone() {
    return new Move(x, y, t);
  }
}

class Player {
  int width, height, myToken, yourToken;
  int[][] board;
  Move temp;
  Move move;
  boolean goOn;

  inline resource constants() =
    \old(width) == width &&
    \old(height) == height &&
    \old(myToken) == myToken &&
    \old(yourToken) == yourToken &&
    \old(temp) == temp &&
    \old(move) == move &&
    \old(board) == board &&
    (\forall int i = 0 .. board.length; \old(board[i]) == board[i]);

  ensures width == m && height == n && myToken == t1 && yourToken == t2;
  ensures matrix(board, width, height);
  ensures (\forall int i = 0..width, int j = 0..height; {: board[i][j] :} == 0);
  ensures goOn == false;
  constructor(int m, int n, int t1, int t2);

  context matrix(board, width, height);
  ensures constants();
  ensures (\forall int i = 0..width, int j = 0..height; \old(board[i][j]) == {: board[i][j] :});
  ensures \old(goOn) == goOn;
  ensures 2 <= move.x && move.x < width - 2;
  ensures 2 <= move.y && move.y < height - 2;
  ensures move.t == myToken;
  ensures board[move.x][move.y] == 0;
  void think();

  context matrix(board, width, height);
  context 2 <= move.x && move.x < width - 2;
  context 2 <= move.y && move.y < height - 2;
  context move.t == myToken || move.t == yourToken;
  requires board[move.x][move.y] == 0;
  ensures constants();
  ensures \old(move.x) == move.x;
  ensures \old(move.y) == move.y;
  ensures \old(move.t) == move.t;
  ensures (\forall int i = 0..width, int j = 0..height;
              (i != move.x || j != move.y) ==> \old({: board[i][j] :}) == board[i][j]);
  ensures board[move.x][move.y] == move.t;
  ensures \old(goOn) == false ==> goOn == false;
  ensures \old(goOn) == true && ((board[move.x-2][move.y] == move.t && board[move.x-1][move.y] == move.t) ||
                                 (board[move.x-1][move.y] == move.t && board[move.x+1][move.y] == move.t) ||
                                 (board[move.x+1][move.y] == move.t && board[move.x+2][move.y] == move.t) ||
                                 (board[move.x][move.y-2] == move.t && board[move.x][move.y-1] == move.t) ||
                                 (board[move.x][move.y-1] == move.t && board[move.x][move.y+1] == move.t) ||
                                 (board[move.x][move.y+1] == move.t && board[move.x][move.y+2] == move.t) ||
                                 (board[move.x-2][move.y-2] == move.t && board[move.x-1][move.y-1] == move.t) ||
                                 (board[move.x-1][move.y-1] == move.t && board[move.x+1][move.y+1] == move.t) ||
                                 (board[move.x+1][move.y+1] == move.t && board[move.x+2][move.y+2] == move.t) ||
                                 (board[move.x+2][move.y-2] == move.t && board[move.x+1][move.y-1] == move.t) ||
                                 (board[move.x+1][move.y-1] == move.t && board[move.x-1][move.y+1] == move.t) ||
                                 (board[move.x-1][move.y+1] == move.t && board[move.x-2][move.y+2] == move.t)) == !goOn;
  void play();
}

inline resource matrix(int[][] mat, int w, int h) =
  mat != null && mat.length == w && (\forall int i = 0 .. w; {: mat[i] :} != null && {: mat[i] :}.length == h);

inline resource consistency(Player p1, Player p2) =
  p1.myToken == p2.yourToken ** p1.yourToken == p2.myToken **
  p1.width == p2.width ** p1.height == p2.height **
  matrix(p1.board, p1.width, p1.height) **
  matrix(p2.board, p2.width, p2.height) **
  (\forall int i = 0..p1.width, int j = 0..p1.height; {: p1.board[i][j] :} == {: p2.board[i][j] :}) **
  p1.goOn == p2.goOn;

seq_program tic_tac_toe(int m, int n) {
  endpoint p1 = Player(m, n, 1, 2);
  endpoint p2 = Player(m, n, 2, 1);

  context consistency(p1, p2);
  void turn1() {
    p1.think();
    p1.play();
    p2.think(); // in the background
    p1.temp := p1.move.clone();
    communicate p2.move <- p1.temp;
    p1.temp := p1.move.clone(); // Workaround - shouldn't be necessary...
    p2.play(); // to update
  }

  context consistency(p1, p2);
  void turn2() {
    p2.think();
    p2.play();
    p1.think(); // in the background
    p2.temp := p2.move.clone();
    communicate p1.move <- p2.temp;
    p2.temp := p2.move.clone(); // Workaround - shouldn't be necessary...
    p1.play(); // to update
  }

  context consistency(p1, p2);
  seq_run {
    loop_invariant consistency(p1, p2);
    while(p1.goOn && p2.goOn){
      turn1();
      if (p1.goOn && p2.goOn) {
        turn2();
      }
    }
  }
}