class Collector {
    int n;
    int[] t0, t1, t2;
    int[] result;
    int nrThreads;
    
    constructor(int nn, int nrT) {
        n = nn;
        t0 = new int[0];
        t1 = new int[0];
        t2 = new int[0];
        result = new int[0];
        nrThreads = nrT;
    }

    requires nrThreads > 0;
    requires n >= 0;
    void flatten() {
        result = new int[n];
        int l = n / nrThreads;
        for(int i = 0; i < l; i++) {
            result[i] = t0[i];
            result[l + i] = t1[i];
            result[2*l + i] = t2[i];
        }
    }
}

class Times {
    int n;
    int[] v,u;
    boolean transpose;
    int seg;

    requires nrThreads > 0;
    ensures n == nn;
    constructor(int nn, boolean transp, int nrThreads) {
        n = nn;
        v = new int[0];
        u = new int[0];
        transpose = transp;
        seg = n / nrThreads;
    }
    
    void runn();
    //assign v

    requires n >= 0;
    void initv() {
        v = new int[n];
    }

    requires n >= 0;
    void initu() {
        u = new int[n];
        loop_invariant 0 <= i && i <= n;
        loop_invariant u.length == n;
        for(int i = 0; i < n; i++) {
            u[i] = 1;
        }
    }
    
}

class Calculator {
    int[] v, u; 
    int n,vBv, vv;
    
    constructor(int nn) {
        v = new int[0];
        u = new int[0];
        n = nn;
    }
    
    void calculate();
    //compute vBv and vv from v and u
}

requires n >= 0;
seq_program spectralNorm(int n) {
    endpoint t0 = Times(n, false, 3);
    endpoint t1 = Times(n, false, 3);
    endpoint t2 = Times(n, false, 3);

    endpoint c = Collector(n, 3);
    endpoint cal = Calculator(n);

    requires t0.n >= 0 && t1.n >= 0 && t2.n >= 0;
    seq_run {
        t0.initu();
        t1.initu();
        t2.initu();
        aTimesTransp();
        communicate t0.u <- c.result;
        communicate t1.u <- c.result;
        communicate t2.u <- c.result;
        t0.transpose := true;
        t1.transpose := true;
        t2.transpose := true;
        aTimesTransp();
        communicate cal.v <- t0.u;
        communicate cal.u <- c.result;
        cal.calculate();
    }
    
    void aTimesTransp() {
        t0.initv();
        t0.runn();
        communicate c.t0 <- t0.v;

        t1.initv();
        t1.runn();
        communicate c.t1 <- t1.v;

        t2.initv();
        t2.runn();
        communicate c.t1 <- t1.v;

        c.flatten(); // x in c.result

        t0.initv();
        communicate t0.u <- c.result;
        t0.runn();
        communicate c.t0 <- t0.v;

        t1.initv();
        communicate t1.u <- c.result;
        t1.runn();
        communicate c.t1 <- t1.v;

        t2.initv();
        communicate t2.u <- c.result;
        t2.runn();
        communicate c.t2 <- t2.v;

        c.flatten(); // v in c.result
    }
}
